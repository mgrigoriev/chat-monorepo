// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	models "github.com/mgrigoriev/chat-monorepo/users/internal/models"
	mock "github.com/stretchr/testify/mock"
)

// UsersStorage is an autogenerated mock type for the UsersStorage type
type UsersStorage struct {
	mock.Mock
}

// CreateFriendship provides a mock function with given fields: ctx, followerID, followedID
func (_m *UsersStorage) CreateFriendship(ctx context.Context, followerID models.UserID, followedID models.UserID) (models.FriendshipID, error) {
	ret := _m.Called(ctx, followerID, followedID)

	if len(ret) == 0 {
		panic("no return value specified for CreateFriendship")
	}

	var r0 models.FriendshipID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UserID, models.UserID) (models.FriendshipID, error)); ok {
		return rf(ctx, followerID, followedID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.UserID, models.UserID) models.FriendshipID); ok {
		r0 = rf(ctx, followerID, followedID)
	} else {
		r0 = ret.Get(0).(models.FriendshipID)
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.UserID, models.UserID) error); ok {
		r1 = rf(ctx, followerID, followedID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUser provides a mock function with given fields: ctx, user
func (_m *UsersStorage) CreateUser(ctx context.Context, user models.User) (models.UserID, error) {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 models.UserID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.User) (models.UserID, error)); ok {
		return rf(ctx, user)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.User) models.UserID); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Get(0).(models.UserID)
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.User) error); ok {
		r1 = rf(ctx, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFriendship provides a mock function with given fields: ctx, friendshipID
func (_m *UsersStorage) DeleteFriendship(ctx context.Context, friendshipID models.FriendshipID) error {
	ret := _m.Called(ctx, friendshipID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFriendship")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FriendshipID) error); ok {
		r0 = rf(ctx, friendshipID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetFriendshipsByUserID provides a mock function with given fields: ctx, userID
func (_m *UsersStorage) GetFriendshipsByUserID(ctx context.Context, userID models.UserID) (*[]models.Friendship, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetFriendshipsByUserID")
	}

	var r0 *[]models.Friendship
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UserID) (*[]models.Friendship, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.UserID) *[]models.Friendship); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]models.Friendship)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.UserID) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserByID provides a mock function with given fields: ctx, id
func (_m *UsersStorage) GetUserByID(ctx context.Context, id models.UserID) (*models.User, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByID")
	}

	var r0 *models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UserID) (*models.User, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.UserID) *models.User); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.UserID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserByEmailAndPassword provides a mock function with given fields: ctx, email, password
func (_m *UsersStorage) GetUserByEmailAndPassword(ctx context.Context, email string, password string) (*models.User, error) {
	ret := _m.Called(ctx, email, password)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByEmailAndPassword")
	}

	var r0 *models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.User, error)); ok {
		return rf(ctx, email, password)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.User); ok {
		r0 = rf(ctx, email, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, email, password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserByToken provides a mock function with given fields: ctx, token
func (_m *UsersStorage) GetUserByToken(ctx context.Context, token models.AuthToken) (*models.User, error) {
	ret := _m.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByToken")
	}

	var r0 *models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.AuthToken) (*models.User, error)); ok {
		return rf(ctx, token)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.AuthToken) *models.User); ok {
		r0 = rf(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.AuthToken) error); ok {
		r1 = rf(ctx, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUsersByNameSubstring provides a mock function with given fields: ctx, nameSubstring
func (_m *UsersStorage) GetUsersByNameSubstring(ctx context.Context, nameSubstring string) (*[]models.User, error) {
	ret := _m.Called(ctx, nameSubstring)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersByNameSubstring")
	}

	var r0 *[]models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*[]models.User, error)); ok {
		return rf(ctx, nameSubstring)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *[]models.User); ok {
		r0 = rf(ctx, nameSubstring)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, nameSubstring)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFriendshipStatus provides a mock function with given fields: ctx, friendshipID, status
func (_m *UsersStorage) UpdateFriendshipStatus(ctx context.Context, friendshipID models.FriendshipID, status string) error {
	ret := _m.Called(ctx, friendshipID, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFriendshipStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.FriendshipID, string) error); ok {
		r0 = rf(ctx, friendshipID, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateUser provides a mock function with given fields: ctx, id, user
func (_m *UsersStorage) UpdateUser(ctx context.Context, id models.UserID, user models.User) (*models.User, error) {
	ret := _m.Called(ctx, id, user)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 *models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.UserID, models.User) (*models.User, error)); ok {
		return rf(ctx, id, user)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.UserID, models.User) *models.User); ok {
		r0 = rf(ctx, id, user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.UserID, models.User) error); ok {
		r1 = rf(ctx, id, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewUsersStorage creates a new instance of UsersStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUsersStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *UsersStorage {
	mock := &UsersStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
